// <STATUSRSK_TEMPORAL_WALLET>
// Executable in Chrome build 57+ and Firefox Stable Release
//
/*
Copyright (c) 2016-2017 Status RSK CO

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:


The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.


THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

(module
  (import $useGas "ethereum" "useGas"
    (param i32))
  (memory 1)
  (export "memory" memory)
  (func $PUSH
    (param $a0 i64)
    (param $a1 i64)
    (param $a2 i64)
    (param $a3 i64)
    (param $sp i32);; increament stack pointer
    (set_local $sp
      (i32.add
        (get_local $sp)
        (i32.const 32)))
    (i64.store
      (get_local $sp)
      (get_local $a3))
    (i64.store
      (i32.add
        (get_local $sp)
        (i32.const 8))
      (get_local $a2))
    (i64.store
      (i32.add
        (get_local $sp)
        (i32.const 16))
      (get_local $a1))
    (i64.store
      (i32.add
        (get_local $sp)
        (i32.const 24))
      (get_local $a0)));; generated by ./wasm/generateInterface.js
  (import $getBlockHash "ethereum" "getBlockHash"
    (param i32 i32))
  (func $BLOCKHASH
    (param $sp i32)
    (call_import $getBlockHash
      (call $check_overflow
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 0)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 8)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 16)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 24))))
      (i32.add
        (get_local $sp)
        (i32.const 0))));; stack:;;  0: word;; -1: offset
  (func $MSTORE
    (param $sp i32)
    (local $memstart i32)
    (local $offset   i32)
    (local $offset0 i64)
    (local $offset1 i64)
    (local $offset2 i64)
    (local $offset3 i64)
    (set_local $memstart
      (i32.const 33832));; load args from the stack
    (set_local $offset0
      (i64.load
        (get_local $sp)))
    (set_local $offset1
      (i64.load
        (i32.add
          (get_local $sp)
          (i32.const 8))))
    (set_local $offset2
      (i64.load
        (i32.add
          (get_local $sp)
          (i32.const 16))))
    (set_local $offset3
      (i64.load
        (i32.add
          (get_local $sp)
          (i32.const 24))))
    (set_local $offset
      (call $check_overflow
        (get_local $offset0)
        (get_local $offset1)
        (get_local $offset2)
        (get_local $offset3)));; subtrace gas useage
    (call $memUseGas
      (get_local $offset)
      (i32.const 32));; pop itme from the stack
    (set_local $sp
      (i32.sub
        (get_local $sp)
        (i32.const 32)));; swap top stack item
    (call $bswap_m256
      (get_local $sp));; FIXME: how to deal with overflow?
    (set_local $offset
      (i32.add
        (get_local $offset)
        (get_local $memstart)));; store word to memory
    (i64.store
      (get_local $offset)
      (i64.load
        (get_local $sp)))
    (i64.store
      (i32.add
        (get_local $offset)
        (i32.const 8))
      (i64.load
        (i32.add
          (get_local $sp)
          (i32.const  8))))
    (i64.store
      (i32.add
        (get_local $offset)
        (i32.const 16))
      (i64.load
        (i32.add
          (get_local $sp)
          (i32.const 16))))
    (i64.store
      (i32.add
        (get_local $offset)
        (i32.const 24))
      (i64.load
        (i32.add
          (get_local $sp)
          (i32.const 24)))));; generated by ./wasm/generateInterface.js
  (import $getCallValue "ethereum" "getCallValue"
    (param i32))
  (func $CALLVALUE
    (param $sp i32)
    (call_import $getCallValue
      (i32.add
        (get_local $sp)
        (i32.const 32)));; zero out mem
    (i64.store
      (i32.add
        (get_local $sp)
        (i32.const 56))
      (i64.const 0))
    (i64.store
      (i32.add
        (get_local $sp)
        (i32.const 48))
      (i64.const 0)))
  (func $ISZERO
    (param $sp i32)
    (local $a0 i64)
    (local $a1 i64)
    (local $a2 i64)
    (local $a3 i64);; load args from the stack
    (set_local $a0
      (i64.load
        (i32.add
          (get_local $sp)
          (i32.const 24))))
    (set_local $a1
      (i64.load
        (i32.add
          (get_local $sp)
          (i32.const 16))))
    (set_local $a2
      (i64.load
        (i32.add
          (get_local $sp)
          (i32.const 8))))
    (set_local $a3
      (i64.load
        (get_local $sp)))
    (i64.store
      (get_local $sp)
      (i64.extend_u/i32
        (call $isZero_i32
          (get_local $a0)
          (get_local $a1)
          (get_local $a2)
          (get_local $a3))));; zero out the rest of memory
    (i64.store
      (i32.add
        (get_local $sp)
        (i32.const 8))
      (i64.const 0))
    (i64.store
      (i32.add
        (get_local $sp)
        (i32.const 16))
      (i64.const 0))
    (i64.store
      (i32.add
        (get_local $sp)
        (i32.const 24))
      (i64.const 0)))
  (func $check_overflow
    (param $a i64)
    (param $b i64)
    (param $c i64)
    (param $d i64)
    (result i32)
    (local $MAX_INT i64);; the eighth Mersenne prime,  2^31 - 1
    (set_local $MAX_INT
      (i64.const 0x7fffffff))
    (if
      (i32.and
        (i32.and
          (i64.eqz
            (get_local $d))
          (i64.eqz
            (get_local $c)))
        (i32.and
          (i64.eqz
            (get_local $b))
          (i64.lt_u
            (get_local $a)
            (get_local $MAX_INT))))
      (then
        (return
          (i32.wrap/i64
            (get_local $a))))
      (else
        (return
          (i32.wrap/i64
            (get_local $MAX_INT))))))
  (func $DUP
    (param $a0 i32)
    (param $sp i32)
    (local $sp_ref i32)
    (set_local $sp
      (i32.add
        (get_local $sp)
        (i32.const 32)))
    (set_local $sp_ref
      (i32.sub
        (i32.sub
          (get_local $sp)
          (i32.const 8))
        (i32.mul
          (get_local $a0)
          (i32.const 32))))
    (i64.store
      (i32.add
        (get_local $sp)
        (i32.const 24))
      (i64.load
        (get_local $sp_ref)))
    (i64.store
      (i32.add
        (get_local $sp)
        (i32.const 16))
      (i64.load
        (i32.sub
          (get_local $sp_ref)
          (i32.const 8))))
    (i64.store
      (i32.add
        (get_local $sp)
        (i32.const  8))
      (i64.load
        (i32.sub
          (get_local $sp_ref)
          (i32.const 16))))
    (i64.store
      (get_local $sp)
      (i64.load
        (i32.sub
          (get_local $sp_ref)
          (i32.const 24)))));; generated by ./wasm/generateInterface.js
  (import $codeCopy "ethereum" "codeCopy"
    (param i32 i32 i32))
  (func $CODECOPY
    (param $sp i32)
    (local $offset0 i32)
    (local $length0 i32)
    (local $memstart i32)
    (set_local $memstart
      (i32.const 33832))
    (set_local $offset0
      (call $check_overflow
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 0)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 8)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 16)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 24)))))
    (set_local $length0
      (call $check_overflow
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const -64)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const -56)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const -48)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const -40)))))
    (call $memUseGas
      (get_local $offset0)
      (get_local $length0))
    (set_local $offset0
      (i32.add
        (get_local $memstart)
        (get_local $offset0)))
    (call $memset
      (get_local $offset0)
      (i32.const 0)
      (get_local $length0))
    (call_import $codeCopy
      (get_local $offset0)
      (call $check_overflow
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const -32)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const -24)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const -16)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const -8))))
      (get_local $length0)));; generated by ./wasm/generateInterface.js
  (import $return "ethereum" "return"
    (param i32 i32))
  (func $RETURN
    (param $sp i32)
    (local $offset0 i32)
    (local $length0 i32)
    (local $memstart i32)
    (set_local $memstart
      (i32.const 33832))
    (set_local $offset0
      (call $check_overflow
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 0)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 8)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 16)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 24)))))
    (set_local $length0
      (call $check_overflow
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const -32)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const -24)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const -16)))
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const -8)))))
    (call $memUseGas
      (get_local $offset0)
      (get_local $length0))
    (set_local $offset0
      (i32.add
        (get_local $memstart)
        (get_local $offset0)))
    (call_import $return
      (get_local $offset0)
      (get_local $length0)))
  (func $memUseGas
    (param $offset i32)
    (param $length i32)
    (local $memstart i32)
    (local $cost i64);; what was charged for the last memory allocation
    (local $prevMemCost i64)
    (local $prevMemCostLoc i32);; the number of 256 words stored in memory
    (local $wordCount i32)
    (local $wordCountLoc i32);; the number of new words being allocated
    (local $newWordCount i32)
    (if
      (i32.eqz
        (get_local $length))
      (then
        (return)));; set globals
    (set_local $memstart
      (i32.const 33832))
    (set_local $wordCountLoc
      (i32.const 32768))
    (set_local $prevMemCostLoc
      (i32.const 32772))
    (set_local $wordCount
      (i32.load
        (get_local $wordCountLoc)))
    (set_local $prevMemCost
      (i64.load
        (get_local $prevMemCostLoc)));; const newMemoryWordCount = Math.ceil[[offset + length] / 32]
    (set_local $newWordCount
      (i32.trunc_u/f32
        (f32.ceil
          (f32.div
            (f32.convert_u/i32
              (i32.add
                (get_local $offset)
                (get_local $length)))
            (f32.const 32)))));;if [runState.highestMem >= highestMem]  return
    (if
      (i32.le_u
        (get_local $newWordCount)
        (get_local $wordCount))
      (then
        (return)));; words * 3 + words ^2 / 512
    (set_local $cost
      (i64.add
        (i64.extend_u/i32
          (i32.mul
            (get_local $newWordCount)
            (i32.const 3)))
        (i64.div_u
          (i64.mul
            (i64.extend_u/i32
              (get_local $newWordCount))
            (i64.extend_u/i32
              (get_local $newWordCount)))
          (i64.const 512))))
    (i64.store
      (get_local $prevMemCostLoc)
      (get_local $cost))
    (set_local $cost
      (i64.sub
        (get_local $cost)
        (get_local $prevMemCost)));; TODO remove once useGas can use i64
    (loop $done $loop
      (if
        (i64.le_u
          (get_local $cost)
          (i64.const 0xffffffff))
        (then
          (br $done)))
      (call_import $useGas
        (i32.const 0xffffffff))
      (set_local $cost
        (i64.sub
          (get_local $cost)
          (i64.const 0xffffffff)))
      (br $loop))
    (call_import $useGas
      (i32.wrap/i64
        (get_local $cost)))
    (i32.store
      (get_local $wordCountLoc)
      (get_local $newWordCount));; grow actual memory  ;; the first 31704 bytes are guaranteed to be available  ;; adjust for 32 bytes  - the maximal size of MSTORE write  ;; TODO it should be current_memory * page_size
    (set_local $offset
      (i32.add
        (get_local $length)
        (i32.add
          (get_local $offset)
          (get_local $memstart))))
    (if
      (i32.gt_u
        (get_local $offset)
        (current_memory))
      (then
        (grow_memory
          (i32.div_u
            (i32.add
              (i32.const 65535)
              (i32.sub
                (get_local $offset)
                (current_memory)))
            (i32.const 65536))))))
  (func $bswap_m256
    (param $sp i32)
    (local $temp i64)
    (set_local $temp
      (call $bswap_i64
        (i64.load
          (get_local $sp))))
    (i64.store
      (get_local $sp)
      (call $bswap_i64
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 24)))))
    (i64.store
      (i32.add
        (get_local $sp)
        (i32.const 24))
      (get_local $temp))
    (set_local $temp
      (call $bswap_i64
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 8)))))
    (i64.store
      (i32.add
        (get_local $sp)
        (i32.const  8))
      (call $bswap_i64
        (i64.load
          (i32.add
            (get_local $sp)
            (i32.const 16)))))
    (i64.store
      (i32.add
        (get_local $sp)
        (i32.const 16))
      (get_local $temp)))
  (func $bswap_i64
    (param $int i64)
    (result i64)
    (i64.or
      (i64.or
        (i64.or
          (i64.and
            (i64.shr_u
              (get_local $int)
              (i64.const 56))
            (i64.const 0xff));; 7 -> 0
          (i64.and
            (i64.shr_u
              (get_local $int)
              (i64.const 40))
            (i64.const 0xff00)));; 6 -> 1
        (i64.or
          (i64.and
            (i64.shr_u
              (get_local $int)
              (i64.const 24))
            (i64.const 0xff0000));; 5 -> 2
          (i64.and
            (i64.shr_u
              (get_local $int)
              (i64.const  8))
            (i64.const 0xff000000))));; 4 -> 3
      (i64.or
        (i64.or
          (i64.and
            (i64.shl
              (get_local $int)
              (i64.const 8))
            (i64.const 0xff00000000));; 3 -> 4
          (i64.and
            (i64.shl
              (get_local $int)
              (i64.const 24))
            (i64.const 0xff0000000000)));; 2 -> 5
        (i64.or
          (i64.and
            (i64.shl
              (get_local $int)
              (i64.const 40))
            (i64.const 0xff000000000000));; 1 -> 6
          (i64.and
            (i64.shl
              (get_local $int)
              (i64.const 56))
            (i64.const 0xff00000000000000))))));; 0 -> 7
  (func $isZero_i32
    (param i64)
    (param i64)
    (param i64)
    (param i64)
    (result i32)
    (i64.eqz
      (i64.or
        (i64.or
          (i64.or
            (get_local 0)
            (get_local 1))
          (get_local 2))
        (get_local 3))));;;; memset from ewasm-libc/ewasm-cleanup;;
  (func $memset
    (param $ptr i32)
    (param $value i32)
    (param $length i32)
    (result i32)
    (local $i i32)
    (set_local $i
      (i32.const 0))
    (loop $done $loop
      (if
        (i32.ge_u
          (get_local $i)
          (get_local $length))
        (br $done))
      (i32.store8
        (i32.add
          (get_local $ptr)
          (get_local $i))
        (get_local $value))
      (set_local $i
        (i32.add
          (get_local $i)
          (i32.const 1)))
      (br $loop))
    (return
      (get_local $ptr)))
  (export "main" $main)
  (func $main
    (local $sp i32)
    (local $jump_dest i32)
    (set_local $sp
      (i32.const -32))
    (set_local $jump_dest
      (i32.const -1))
    (loop $done $loop
      (block $4
        (block $3
          (block $2
            (block $1
              (block $0
                (br_table $0 $1 $2 $3
                  (if
                    (i32.eq
                      (get_local $jump_dest)
                      (i32.const 32))
                    (then
                      (i32.const 3))
                    (else
                      (if
                        (i32.eq
                          (get_local $jump_dest)
                          (i32.const 14))
                        (then
                          (i32.const 2))
                        (else
                          (if
                            (i32.eq
                              (get_local $jump_dest)
                              (i32.const 13))
                            (then
                              (i32.const 1))
                            (else
                              (if
                                (i32.eq
                                  (get_local $jump_dest)
                                  (i32.const -1))
                                (then
                                  (i32.const 0))
                                (else
                                  (unreachable)))))))))))
              (call_import $useGas
                (i32.const 22))
              (if
                (i32.gt_s
                  (get_local $sp)
                  (i32.const 32672))
                (then
                  (unreachable)))
              (if
                (i32.lt_s
                  (get_local $sp)
                  (i32.const 0))
                (then
                  (unreachable)))
              (call $PUSH
                (i64.const 0)
                (i64.const 0)
                (i64.const 0)
                (i64.const 96)
                (get_local $sp))
              (set_local $sp
                (i32.add
                  (get_local $sp)
                  (i32.const 32)))
              (call $BLOCKHASH
                (get_local $sp))
              (call $MSTORE
                (get_local $sp))
              (set_local $sp
                (i32.add
                  (get_local $sp)
                  (i32.const -64)))
              (call $CALLVALUE
                (get_local $sp))
              (set_local $sp
                (i32.add
                  (get_local $sp)
                  (i32.const 32)))
              (call $ISZERO
                (get_local $sp))
              (call $PUSH
                (i64.const 0)
                (i64.const 0)
                (i64.const 0)
                (i64.const 14)
                (get_local $sp))
              (set_local $sp
                (i32.add
                  (get_local $sp)
                  (i32.const 32)))
              (set_local $jump_dest
                (call $check_overflow
                  (i64.load
                    (get_local $sp))
                  (i64.load
                    (i32.add
                      (get_local $sp)
                      (i32.const 8)))
                  (i64.load
                    (i32.add
                      (get_local $sp)
                      (i32.const 16)))
                  (i64.load
                    (i32.add
                      (get_local $sp)
                      (i32.const 24)))))
              (set_local $sp
                (i32.sub
                  (get_local $sp)
                  (i32.const 64)))
              (br_if $loop
                (i32.eqz
                  (i64.eqz
                    (i64.or
                      (i64.load
                        (i32.add
                          (get_local $sp)
                          (i32.const 32)))
                      (i64.or
                        (i64.load
                          (i32.add
                            (get_local $sp)
                            (i32.const 40)))
                        (i64.or
                          (i64.load
                            (i32.add
                              (get_local $sp)
                              (i32.const 48)))
                          (i64.load
                            (i32.add
                              (get_local $sp)
                              (i32.const 56)))))))))
              (call_import $useGas
                (i32.const 6))
              (if
                (i32.gt_s
                  (get_local $sp)
                  (i32.const 32672))
                (then
                  (unreachable)))
              (unreachable))
            (call_import $useGas
              (i32.const 1)))
          (call_import $useGas
            (i32.const 16))
          (if
            (i32.gt_s
              (get_local $sp)
              (i32.const 32608))
            (then
              (unreachable)))
          (call $PUSH
            (i64.const 0)
            (i64.const 0)
            (i64.const 0)
            (i64.const 54)
            (get_local $sp))
          (set_local $sp
            (i32.add
              (get_local $sp)
              (i32.const 32)))
          (call $DUP
            (i32.const 0)
            (get_local $sp))
          (set_local $sp
            (i32.add
              (get_local $sp)
              (i32.const 32)))
          (call $PUSH
            (i64.const 0)
            (i64.const 0)
            (i64.const 0)
            (i64.const 28)
            (get_local $sp))
          (set_local $sp
            (i32.add
              (get_local $sp)
              (i32.const 32)))
          (call $PUSH
            (i64.const 0)
            (i64.const 0)
            (i64.const 0)
            (i64.const 0)
            (get_local $sp))
          (set_local $sp
            (i32.add
              (get_local $sp)
              (i32.const 32)))
          (call $CODECOPY
            (get_local $sp))
          (set_local $sp
            (i32.add
              (get_local $sp)
              (i32.const -96)))
          (call $PUSH
            (i64.const 0)
            (i64.const 0)
            (i64.const 0)
            (i64.const 0)
            (get_local $sp))
          (set_local $sp
            (i32.add
              (get_local $sp)
              (i32.const 32)))
          (call $RETURN
            (get_local $sp))
          (br $done)
          (set_local $sp
            (i32.add
              (get_local $sp)
              (i32.const -64))))
        (call_import $useGas
          (i32.const 7))
        (if
          (i32.gt_s
            (get_local $sp)
            (i32.const 32672))
          (then
            (unreachable)))
        (unreachable)))))
